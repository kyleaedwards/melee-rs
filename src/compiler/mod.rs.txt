  public compile(node: ast.Node): void {
    } else if (node instanceof ast.AssignExpression) {
      const name = node.name;
      if (!(name instanceof ast.Identifier)) {
        // Assignment for array expressions
        if (name instanceof ast.IndexExpression) {
          this.compile(name.collection);
          this.compile(name.index);
          if (node.value) {
            this.compile(node.value);
          }
          this.emit(Opcode.SET_INDEX);

          this.compile(name.collection);
          this.compile(name.index);
          this.emit(Opcode.INDEX);
          return;
        }
        throw new CompilerError(
          'Left-hand of assignment must be a variable or an array index expression',
          name.token,
        );
      }
      const sym = this.symbolTable.get(name.value);
      if (!sym) {
        throw new CompilerError(
          `Cannot assign undefined variable ${name.value}`,
          name.token,
        );
      }
      if (node.value) {
        this.compile(node.value);
      }
      let opcode: Opcode;
      let fetch: Opcode;
      switch (sym.type) {
        case ScopeType.FREE:
          opcode = Opcode.SETC;
          fetch = Opcode.GETC;
          break;
        case ScopeType.LOCAL:
          opcode = Opcode.SET;
          fetch = Opcode.GET;
          break;
        case ScopeType.GLOBAL:
          opcode = Opcode.SETG;
          fetch = Opcode.GETG;
          break;
        default:
          throw new CompilerError(
            `Cannot assign unassigned variable ${name.value}`,
            name.token,
          );
      }
      this.emit(opcode, sym.index);
      this.emit(fetch, sym.index);
    } else if (node instanceof ast.CompoundAssignExpression) {
      const name = node.name;
      if (!(name instanceof ast.Identifier)) {
        // Assignment for array expressions
        if (name instanceof ast.IndexExpression) {
          this.compile(name.collection);
          this.compile(name.index);
          this.compile(name.collection);
          this.compile(name.index);
          this.emit(Opcode.INDEX);
          if (node.value) {
            this.compile(node.value);
          }
          switch (node.operator) {
            case '+=':
              this.emit(Opcode.ADD);
              break;
            case '-=':
              this.emit(Opcode.SUB);
              break;
            case '*=':
              this.emit(Opcode.MUL);
              break;
            case '/=':
              this.emit(Opcode.DIV);
              break;
            case '%=':
              this.emit(Opcode.MOD);
              break;
          }
          this.emit(Opcode.SET_INDEX);

          this.compile(name.collection);
          this.compile(name.index);
          this.emit(Opcode.INDEX);
          return;
        }
        throw new CompilerError(
          'Left-hand of assignment must be a variable or an array index expression',
          name.token,
        );
      }
      const sym = this.symbolTable.get(name.value);
      if (!sym) {
        throw new CompilerError(
          `Cannot assign undefined variable ${name.value}`,
          name.token,
        );
      }
      this.compile(name);
      if (node.value) {
        this.compile(node.value);
      }
      switch (node.operator) {
        case '+=':
          this.emit(Opcode.ADD);
          break;
        case '-=':
          this.emit(Opcode.SUB);
          break;
        case '*=':
          this.emit(Opcode.MUL);
          break;
        case '/=':
          this.emit(Opcode.DIV);
          break;
        case '%=':
          this.emit(Opcode.MOD);
          break;
      }

      let opcode: Opcode;
      let fetch: Opcode;
      switch (sym.type) {
        case ScopeType.FREE:
          opcode = Opcode.SETC;
          fetch = Opcode.GETC;
          break;
        case ScopeType.LOCAL:
          opcode = Opcode.SET;
          fetch = Opcode.GET;
          break;
        case ScopeType.GLOBAL:
          opcode = Opcode.SETG;
          fetch = Opcode.GETG;
          break;
        default:
          throw new CompilerError(
            `Cannot assign unassigned variable ${name.value}`,
            name.token,
          );
      }
      this.emit(opcode, sym.index);
      this.emit(fetch, sym.index);
    } else if (node instanceof ast.Identifier) {
      const sym = this.symbolTable.get(node.value);
      if (typeof sym === 'undefined') {
        throw new CompilerError(
          `Attempting to use undefined variable ${node.value}`,
          node.token,
        );
      }
      let opcode: Opcode;
      switch (sym.type) {
        case ScopeType.FREE:
          opcode = Opcode.GETC;
          break;
        case ScopeType.NATIVE:
          opcode = Opcode.GETN;
          break;
        case ScopeType.GLOBAL:
          opcode = Opcode.GETG;
          break;
        case ScopeType.SELF:
          opcode = Opcode.SELF;
          break;
        default:
          opcode = Opcode.GET;
      }
      this.emit(opcode, sym.index);
    } else if (node instanceof ast.PrefixExpression) {
      if (node.right) {
        this.compile(node.right);
      }
      switch (node.operator) {
        case '-':
          this.emit(Opcode.MINUS);
          break;
        case '!':
          this.emit(Opcode.BANG);
          break;
      }
    } else if (node instanceof ast.InfixExpression) {
      if (node.operator === '<' || node.operator === '<=') {
        if (node.right) {
          this.compile(node.right);
        }
        if (node.left) {
          this.compile(node.left);
        }
        this.emit(node.operator === '<' ? Opcode.GT : Opcode.GTE);
        return;
      }
      if (node.left) {
        this.compile(node.left);
      }
      if (node.right) {
        this.compile(node.right);
      }
      switch (node.operator) {
        case '+':
          this.emit(Opcode.ADD);
          break;
        case '-':
          this.emit(Opcode.SUB);
          break;
        case '*':
          this.emit(Opcode.MUL);
          break;
        case '/':
          this.emit(Opcode.DIV);
          break;
        case '%':
          this.emit(Opcode.MOD);
          break;
        case '==':
          this.emit(Opcode.EQ);
          break;
        case '!=':
          this.emit(Opcode.NOT_EQ);
          break;
        case '>':
          this.emit(Opcode.GT);
          break;
        case '>=':
          this.emit(Opcode.GTE);
          break;
        case '&&':
          this.emit(Opcode.AND);
          break;
        case '||':
          this.emit(Opcode.OR);
          break;
      }
    } else if (node instanceof ast.IntegerLiteral) {
      // TODO: Why use constants for MIDI Ints, could we just bake them
      // into the bytecode instead?
      const o = Int.from(node.value);
      this.emit(Opcode.CONST, this.addConstant(o));
    } else if (node instanceof ast.BooleanLiteral) {
      this.emit(node.value ? Opcode.TRUE : Opcode.FALSE);
    } else if (node instanceof ast.ArrayLiteral) {
      node.values.forEach(this.compile.bind(this));
      this.emit(Opcode.ARRAY, node.values.length);
    } else if (node instanceof ast.IndexExpression) {
      this.compile(node.collection);
      this.compile(node.index);
      this.emit(Opcode.INDEX);
    } else if (
      node instanceof ast.FunctionLiteral ||
      node instanceof ast.GeneratorLiteral
    ) {
      this.pushScope();
      if (node.name) {
        this.symbolTable.setSelf(node.name);
      }
      node.parameters.forEach((param) => {
        this.symbolTable.add(param.value);
      });
      this.compile(node.body);

      const { freeSymbols, numSymbols } = this.symbolTable;

      if (this.scope().lastInstruction.opcode !== Opcode.RET) {
        this.emit(Opcode.NULL);
        this.emit(Opcode.RET);
      }
      const instructions = this.popScope();
      if (!instructions) {
        throw new CompilerError(
          'Error compiling function',
          node.token,
        );
      }

      freeSymbols.forEach((sym) => {
        let opcode: Opcode;
        switch (sym.type) {
          case ScopeType.FREE:
            opcode = Opcode.GETC;
            break;
          case ScopeType.NATIVE:
            opcode = Opcode.GETN;
            break;
          case ScopeType.GLOBAL:
            opcode = Opcode.GETG;
            break;
          case ScopeType.SELF:
            opcode = Opcode.SELF;
            break;
          default:
            opcode = Opcode.GET;
        }
        this.emit(opcode, sym.index);
      });

      const repr = node.toString();
      const CallableConstructor =
        node instanceof ast.FunctionLiteral ? Fn : Gen;
      const fn = new CallableConstructor(
        instructions,
        repr,
        numSymbols,
        node.parameters.length,
      );
      this.emit(
        Opcode.CLOSURE,
        this.addConstant(fn),
        freeSymbols.length,
      );
    } else if (node instanceof ast.NextExpression) {
      if (!node.right) {
        throw new CompilerError(
          'Cannot use the `next` keyword without an operand',
          node.token,
        );
      } else {
        this.compile(node.right);
      }
      this.emit(Opcode.NEXT);
    } else if (node instanceof ast.CallExpression) {
      if (!node.fn) {
        throw new CompilerError(
          'Invalid call expression',
          node.token,
        );
      }
      this.compile(node.fn);
      node.args.forEach(this.compile.bind(this));
      this.emit(Opcode.CALL, node.args.length);
      const identifier = this.symbolTable.add(node.identifier.value);
      const setter =
        this.symbolTable.type === ScopeType.GLOBAL
          ? Opcode.SETG
          : Opcode.SET;
      const getter =
        this.symbolTable.type === ScopeType.GLOBAL
          ? Opcode.GETG
          : Opcode.GET;
      const counter = this.symbolTable.addIota();
      const collection = this.symbolTable.addIota();
      const incr = this.addConstant(Int.from(1));

      // Set counter
      this.emit(Opcode.CONST, this.addConstant(Int.from(0)));
      this.emit(setter, counter);

      // Save collection
      this.compile(node.collection);
      this.emit(setter, collection);

      this.loopStarts.push(this.instructions().length);
      this.breaks.push([]);

      // Check if iterator has gone past the end of the arra
      this.emit(getter, collection);
      this.emit(Opcode.LEN);
      this.emit(getter, counter);
      this.emit(Opcode.GT);
      const jumpOut = this.emit(Opcode.JMP_IF_NOT, 0xffff);

      // Set the current array item in the local variable
      this.emit(getter, collection);
      this.emit(getter, counter);
      this.emit(Opcode.INDEX);
      this.emit(setter, identifier);

      // Increment the iterator
      this.emit(getter, counter);
      this.emit(Opcode.CONST, incr);
      this.emit(Opcode.ADD);
      this.emit(setter, counter);

      // Compile code block and loop
      this.compile(node.block);
      this.emit(
        Opcode.JMP,
        this.loopStarts[this.loopStarts.length - 1],
      );
      this.replaceInstruction(jumpOut, this.instructions().length);
      while (this.breaks[this.breaks.length - 1].length) {
        const brk = this.breaks[this.breaks.length - 1].pop();
        if (brk) {
          this.replaceInstruction(brk, this.instructions().length);
        }
      }
      this.breaks.pop();
      this.loopStarts.pop();
    } else if (node instanceof ast.NoteExpression) {
      if (!node.args) {
        throw new CompilerError(
          'Cannot use the `note` keyword without arguments',
          node.token,
        );
      }
      node.args.forEach(this.compile.bind(this));
      this.emit(Opcode.NOTE, node.args.length);
    } else if (node instanceof ast.RestExpression) {
      if (!node.args) {
        throw new CompilerError(
          'Cannot use the `rest` keyword without arguments',
          node.token,
        );
      }
      node.args.forEach(this.compile.bind(this));
      this.emit(Opcode.REST, node.args.length);
    } else if (node instanceof ast.CCExpression) {
      if (!node.args) {
        throw new CompilerError(
          'Cannot use the `cc` keyword without arguments',
          node.token,
        );
      }
      node.args.forEach(this.compile.bind(this));
      this.emit(Opcode.CC, node.args.length);
    }
  }
}
